{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Mapsui is a .NET map component that supports all main .NET UI frameworks. </p> UI Framework NuGet MAUI WPF Avalonia Uno Platform Blazor WinUI .NET for Android .NET for iOS Eto Forms Windows Forms <p>Try the quick-start for your favorite framework below.</p> <p>Quickstart</p> MAUIUnoAvaloniaBlazorWPFWinUI.NET for iOS.NET for AndroidEto FormsWindows Forms <p>Step 1: Create a new .NET 7.0 MAUI application in Visual Studio.</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.Maui\n</code></pre> <p>Step 3: IMPORTANT: In MauiProgram.cs add .UseSkiaSharp() to the builder like this:</p> <pre><code>builder\n    .UseMauiApp&lt;App&gt;()\n    .UseSkiaSharp(true)\n    .ConfigureFonts(fonts =&gt;  \n</code></pre> <p>and add namespace 'SkiaSharp.Views.Maui.Controls.Hosting':</p> <pre><code>using SkiaSharp.Views.Maui.Controls.Hosting;\n</code></pre> <p>This is because Mapsui depends on SkiaSharp which needs this call. We hope that this will not be necessary in a future version of Mapsui.Maui. Without this line the app will crash with this exception: <code>Catastrophic failure (0x8000FFFF (E_UNEXPECTED))</code> on Windows and with <code>Microsoft.Mapsui.Platform.HandlerNotFoundException has been thrown</code> on Mac.</p> <p>Step 4: In MainPage.xaml.cs replace the constuctor with this code:</p> <pre><code>public MainPage()\n{\n    InitializeComponent();\n\n    var mapControl = new Mapsui.UI.Maui.MapControl();\n    mapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\n    Content = mapControl;\n}\n</code></pre> <p>Step 5: Run it and you should see a map of the world.</p> <p>Preparation: See Uno Platform getting started</p> <p>Step 1: Create new 'Uno Platform App' in Visual Studio</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.Uno.WinUI\n</code></pre> <p>Repeat this for all the targets you are using (Change the default Project in the Package Manager Console)</p> <p>Step 3: Open MainPage.xaml and add namespace:</p> <pre><code>xmlns:mapsui=\"clr-namespace:Mapsui.UI.WinUI;assembly=Mapsui.UI.Uno.WinUI\"\n</code></pre> <p>Add MapControl to the Grid:</p> <pre><code>&lt;Grid&gt;\n    &lt;mapsui:MapControl x:Name=\"MyMap\" VerticalAlignment=\"Stretch\" HorizontalAlignment=\"Stretch\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>In MainPage.xaml.cs, add namespace:</p> <pre><code>using Mapsui.Utilities;\n</code></pre> <p>Add code to the constructor:</p> <pre><code>public MainPage()\n{\n    this.InitializeComponent();\n    MyMap.Map.Layers.Add(OpenStreetMap.CreateTileLayer());\n}\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Troubleshooting:</p> <ul> <li> <p>Unable to resolve the .NET SDK version as specified in the global.json. global.json (change the version to \"6.0.400\" or what is installed on the Computer)</p> </li> <li> <p>Duplicate Attribute errors: Add following line to the ...Wpf.csproj.</p> </li> </ul> <pre><code>    &lt;!-- Work around https://github.com/dotnet/wpf/issues/6792 --&gt;\n    &lt;ItemGroup&gt;\n    &lt;FilteredAnalyzer Include=\"@(Analyzer-&gt;Distinct())\" /&gt;\n    &lt;Analyzer Remove=\"@(Analyzer)\" /&gt;\n    &lt;Analyzer Include=\"@(FilteredAnalyzer)\" /&gt;\n    &lt;/ItemGroup&gt;\n&lt;/Target&gt;\n</code></pre> <ul> <li>System.MissingMethodException: Method not found: See for solution here https://github.com/unoplatform/uno/issues/9297</li> </ul> <p>Upgrading to the latest Uno.UI Dev Version should help too.</p> <p>Preperation: Install the Avalonia templates:</p> <pre><code>dotnet new install Avalonia.Templates\n</code></pre> <p>Step 1: Create a new Avalonia project:</p> <pre><code>dotnet new avalonia.app -o MyApp\n</code></pre> <p>Step 2: Add the Mapsui.Avalonia nuget package:</p> <pre><code>dotnet add MyApp package Mapsui.Avalonia\n</code></pre> <p>Step 3: In MainWindow.axaml.cs add this to the constructor after InitializeComponent():</p> <pre><code>var mapControl = new Mapsui.UI.Avalonia.MapControl();\nmapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\nContent = mapControl;\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <pre><code>cd MyApp\ndotnet run\n</code></pre> <p>Step 1: Create a new Blazor WebAssembly Application in your IDE and select .NET 7.0 (Standard Term Support) as Framework.</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.Blazor\n</code></pre> <p>Step 3: In Index.razor add this to the to Page.</p> <pre><code>@using Mapsui.UI.Blazor\n</code></pre> <pre><code>&lt;div class=\"container\"&gt;\n    &lt;div class=\"row\"&gt;\n        &lt;div class=\"col border rounded p-2 canvas-container\"&gt;\n            &lt;MapControlComponent @ref=\"_mapControl\" /&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;style&gt;\n    .canvas-container canvas {\n        width: 100%;\n        height: 80vh;\n    }\n&lt;/style&gt;\n</code></pre> <pre><code>@code \n{\n    private MapControl? _mapControl;\n\n    protected override void OnAfterRender(bool firstRender)\n    {\n        base.OnAfterRender(firstRender);\n        if (firstRender)\n        {\n            if (_mapControl != null)\n                _mapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\n        }\n    }\n}\n</code></pre> <p>Step 6: Run it and you should see a map of the world.</p> <p>Troubleshooting:</p> <ul> <li>Text is not displayed Add Follwing to the Blazor project, is a workaround that text is rendered.</li> </ul> <pre><code>&lt;ItemGroup&gt;\n    &lt;PackageReference Include=\"HarfBuzzSharp.NativeAssets.WebAssembly\" Version=\"2.8.2.3\" GeneratePathProperty=\"true\" /&gt;\n    &lt;NativeFileReference Include=\"$(PKGHarfBuzzSharp_NativeAssets_WebAssembly)\\build\\netstandard1.0\\libHarfBuzzSharp.a\\3.1.12\\libHarfBuzzSharp.a\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre> <p>Step 1: Start a new WPF application in Visual Studio.</p> <p>Step 2: In the package manager console type: <pre><code>PM&gt; Install-Package Mapsui.Wpf\n</code></pre></p> <p>Step 3: In MainWindow.xaml.cs add in the constructor after InitializeComponent():</p> <pre><code>var mapControl = new Mapsui.UI.Wpf.MapControl();\nmapControl.Map?.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\nContent = mapControl;\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Step 1: Create new 'Blank App. Packaged (WinUI 3 in Desktop)' in Visual Studio</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.WinUI\n</code></pre> <p>Step 3: Open MainPage.xaml and add namespace:</p> <pre><code>xmlns:winui=\"using:Mapsui.UI.WinUI\"\n</code></pre> <p>Add MapControl to the Grid:</p> <pre><code>&lt;Grid&gt;\n    &lt;winui:MapControl x:Name=\"MyMap\" VerticalAlignment=\"Stretch\" HorizontalAlignment=\"Stretch\" /&gt;\n&lt;/Grid&gt;\n</code></pre> <p>In MainPage.xaml.cs, add namespace:</p> <pre><code>using Mapsui.Utilities;\n</code></pre> <p>Add code to the constructor:</p> <pre><code>public MainPage()\n{\n    this.InitializeComponent();\n    MyMap.Map.Layers.Add(OpenStreetMap.CreateTileLayer());\n}\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Step 1: Create new 'Single View App' in Visual Studio</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.iOS\n</code></pre> <p>Step 3: Open ViewController.cs and add namespaces:</p> <pre><code>using Mapsui;\nusing Mapsui.UI.iOS;\nusing Mapsui.Utilities;\n</code></pre> <p>add code to ViewDidLoad() method:</p> <pre><code>public override void ViewDidLoad()\n{\n    base.ViewDidLoad();\n\n    var mapControl = new MapControl(View.Bounds);\n    var map = new Map();\n    map.Layers.Add(OpenStreetMap.CreateTileLayer());\n    mapControl.Map = map;\n    View = mapControl;\n}\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Step 1: Create 'Blank App (Android)' in Visual Studio</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.Android\n</code></pre> <p>Step 3: In Resources/layout/Main.axml add Mapsui.UI.Android.MapControl:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"&gt;\n    &lt;Mapsui.UI.Android.MapControl\n        android:id=\"@+id/mapcontrol\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\" /&gt;\n&lt;/LinearLayout&gt;\n</code></pre> <p>Step 4: In MainActivity.cs add MapControl after SetContentView(Resource.Layout.Main):</p> <pre><code>protected override void OnCreate(Bundle savedInstanceState)\n{\n    base.OnCreate(savedInstanceState);\n\n    // Set our view from the \"main\" layout resource\n    SetContentView(Resource.Layout.Main);\n\n    var mapControl = FindViewById&lt;MapControl&gt;(Resource.Id.mapcontrol);\n    var map = new Map();\n    map.Layers.Add(OpenStreetMap.CreateTileLayer());\n    mapControl.Map = map;\n}\n</code></pre> <p>Add the following using statements:</p> <pre><code>using Mapsui;\nusing Mapsui.Utilities;\nusing Mapsui.UI.Android;\n</code></pre> <p>Step 5: Run it and you should see a map of the world.</p> <p>Step 1: Start a new Eto.Forms application in Visual Studio.</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.Eto\n</code></pre> <p>Step 3: In MainForm.cs add this to the class constructor:</p> <pre><code>var mapControl = new Mapsui.UI.Eto.MapControl();\nmapControl.Map.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\nContent = mapControl;\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p> <p>Step 1: Start a new Windows Forms App in Visual Studio.</p> <p>Step 2: In the package manager console type:</p> <pre><code>PM&gt; Install-Package Mapsui.WindowsForms\n</code></pre> <p>Step 3: In Form1.cs add this to the class constructor:</p> <pre><code>var mapControl = new MapControl();\nControls.Add(mapControl);\nmapControl.Map.Layers.Add(Mapsui.Tiling.OpenStreetMap.CreateTileLayer());\n</code></pre> <p>Step 4: Run it and you should see a map of the world.</p>"},{"location":"#functionality","title":"Functionality","text":"<ul> <li>Points, Lines and Polygons using NTS, a mature library which support all kinds of geometric operations. </li> <li>OpenStreetMap tiles based on BruTile library and almost all other tile sources.</li> <li>OGC standards with data providers for WMS, WFS and WMTS.</li> <li>Offline maps are possible using MBTiles implemented with BruTile.MBTiles. This stores map tiles in a sqlite file.</li> <li>Generates static map images to could be embedded in PDFs. </li> </ul>"},{"location":"#other-resources","title":"Other resources:","text":"<ul> <li>API documentation Mapsui</li> <li>Mapsui on GitHub</li> <li>Online samples in Blazor for Mapsui</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For paid support in the form of contract work or consoluting mail: info.mapsui@gmail.com.</p>"},{"location":"async-fetching/","title":"Asynchronous Data Fetching","text":""},{"location":"async-fetching/#some-background","title":"Some background","text":"<p>To get smooth performance while panning and zooming data needs to be fetched on a background thread. Even if it is fetched on a background thread it will use resources which could be noticible in the responsiveness of the map. The asyncronous data fetching of Mapsui tries to take this into account to optimize the user experience.</p>"},{"location":"async-fetching/#changetype","title":"ChangeType","text":"<p>(ChangeType was introduced in V3, in V2 the majorType boolean has this purpose)</p> <p>When calling the RefreshData method on the layers we pass in a ChangeType parameter which could be:</p> <ul> <li>Continous - During dragging, pinching zoom, or animations.</li> <li>Discrete - On zoom in/out button press, on touch up, or at the end of an animation.</li> </ul> <p>The layers itself decides how to respond to the refresh call. For different data types different strategies are used.</p>"},{"location":"async-fetching/#tilelayer-data-fetching","title":"TileLayer data fetching","text":"<p>The diagram below shows how the TileLayers data fetcher works. The data fetcher runs on a background thread. The UI and Fetcher communicate through non blocking messages. Whenever the user pans or zooms a View Changed message is sent to the Fetcher. This will trigger the fetcher to start fetching data. Whenever new data arrives a Data Changed message is sent to the UI so that it knows it should redraw the map. The fetcher dumps incoming data into a cache. The UI renderer retrieves whatever is needed from that cache when rendering, not taking into account what the data fetcher is doing. This loose coupling keeps things simple and flexible and the renderer never has to wait for the fetcher which results in a smooth (perceived) performance.</p>"},{"location":"async-fetching/#readwrite-cache","title":"Read/Write cache","text":"<p>For rendering the cache is only read. For data fetching the cache is primarily written but it is also needs to read the cache in order to know which data is already available and does not need to be fetched.</p>"},{"location":"async-fetching/#strategies","title":"Strategies","text":"<p>Both the fetcher and the renderer can use some smart tricks to optimize the experience, for example:</p> <ul> <li>The fetcher can pre\u2010fetch tiles that are not directly needed but could be in the future.</li> <li>The renderer could search for alternative tiles (higher or lower levels) when the optimal tiles are not available. </li> </ul> <p>The implementation of these strategies can be overridden by the user by implementing interfaces that can be passed into the TileLayer constructor.</p> <ul> <li>The IDataFetchStrategy (IFetchStrategy in V2) determines which tiles are fetched from the data source to be stored in the cache. There is a DataFetchStrategy default implementation and a MinimalDataFetchStrategy which only fetches the tiles directly needed.</li> <li>The IRenderFetchStrategy (IRenderGetStrategy in V2) determines which tiles are fetched from the cache to use for rendering. There is a RenderFetchStrategy default implementation and a MinimalRenderFetchStrategy which only fetches the tiles directly needed.</li> </ul> <p>Those strategies should be tuned to support each other. For instance, in the current implementation the renderer uses higher level tiles when the optimal tiles are not available, and the fetcher pre\u2010fetches higher level tiles to assist the renderer. The way they play together is not specified in the interface so developers should take this into account.</p> <p></p>"},{"location":"async-fetching/#data-fetching-in-other-layers","title":"Data fetching in other layers","text":"<p>Other layers like the Layer and ImageLayer have their own implementation. They use a delay mechanism in fetching new data and ignore ChangeType.Continuous.</p>"},{"location":"contributors-guidelines/","title":"Mapsui Contributor Guidelines","text":"<p>Note: Below are some contributor guidelines. Items were added when we felt it was useful. It is not intended to be some complete list.</p>"},{"location":"contributors-guidelines/#if-you-want-to-contribute-you-need-to-sign-the-contributor-license-agreement-cla","title":"If you want to contribute you need to sign the Contributor License Agreement (CLA)","text":""},{"location":"contributors-guidelines/#issues-first","title":"Issues first","text":"<p>Submit an issue before a pull request so we can discuss the possible solutions to the problem.</p>"},{"location":"contributors-guidelines/#create-small-prs-that-are-about-one-topic","title":"Create small PRs that are about one topic","text":"<p>To be able to review a PR it helps if it is a small change which covers only one topic. For the reviewer it is important to understand the purpose. Take the reviewer along in your own thinking steps. There was a problem, you considered solutions, and there was a reason why you came to this solution. The diff shows what has changed. What should be clear from the PR desciption, commits and code comments is the 'why'.</p>"},{"location":"contributors-guidelines/#for-bigger-changes-work-with-pr-dependencies","title":"For bigger changes work with PR dependencies","text":"<p>If you create a PR and want to make additional changes based on the earlier changes you should create a new PR that depends and the previous PR. Mention in the description that it depends on the other PR. Once the previous PR was merged you can update the next one with <code>git pull origin main</code> on the commend line. If you do not really need PR dependencies (because the changes are not really related) then it is preferred to create independent PRs.</p>"},{"location":"contributors-guidelines/#formatting","title":"Formatting","text":"<p>We use .editorconfig in our repository and the code should comply to this. To apply specifc rules in Visual Studio you can select a project | context menu | Analyze and Code Cleanup | Run Code Cleanup (Profile 1 of 2). You can configure which rules to apply in these profiles. Alternatively you can use the dotnet format command.</p>"},{"location":"contributors-guidelines/#all-checks-should-be-green-all-the-time","title":"All checks should be green all the time","text":"<p>At all times: - All projects should compile - The unit tests should succeed - All samples should run properly</p>"},{"location":"contributors-guidelines/#keep-the-core-code-reliable-and-deal-with-potential-problems-on-the-surface","title":"Keep the core code reliable and deal with potential problems on the surface","text":"<p>Code depends on other code. In a hierarchy it is better to have the most reliable code in the core. You don't want potential problems to be propagated from the core to all other code because everything would becomee problematic. Potential problems are: - IDisposable objects. You don't want callers to have to deal that. You don't want other code to have to decide about disposing or not. - Code that is async/await. Synchronous code is simpler. Calls are async/await because of long lasting calls which is often because of calls to external services. Those depend on network which could be slow or missing and the size of the data which could be bigger than expected. - Code that could throw an exception, so the caller has to catch it, or perhaps it should not need to catch it (it is better if you do not have to decide). - Fields that are nullable. Check for null early on the surface before passing it along to the core.</p> <p>An examples of the kind thing we want to avoid is the layering in: DataSource &lt;- Fetcher &lt;- Layer &lt;- Map &lt;- MapControl. In our current code all those objects become IDisposable because of the design.</p> <p>This may come down to this simple general advice: Prefer pure functions. Perhaps this seems like a very local thing to do but sometimes you need to reorganize your global architecture to make it possible to have more pure functions.</p>"},{"location":"contributors-guidelines/#extension-methods","title":"Extension methods","text":"<ul> <li>Extension methods should always be in an 'Extensions' folder. </li> <li>They should be in a class that has the name '{ClassItExtends}Extensions'. </li> <li>It should be in a namespace that follows the folder name (so not in the namespace of the class it extends).</li> <li>Extensions of a collection (IEnumerable, List, Array etc) of a type should also be in the class that extends the individual type.</li> <li>If an interface is extended, the I should not be in the class name. So and ILayer extension should be LayerExtensions.</li> </ul>"},{"location":"contributors-guidelines/#direct-and-indirect-nuget-dependencies-should-point-to-the-same-version","title":"Direct and indirect nuget dependencies should point to the same version","text":"<p>For instance, we have a direct dependency on SkiaSharp, but we also use Svg.Skia which has a dependency on SkiaSharp too. We want both of those to point to the same version. If not, linking or runtime errors could occur. In some cases this might not be possible, for instance, when we have to downgrade because of a bug in some package.</p>"},{"location":"contributors-guidelines/#pr-titles-should-be-written-as-release-notes","title":"PR titles should be written as release notes","text":"<p>Github can generate release notes from PR titles, so the PR titles should be written as release notes entries. Let's do it like this:</p> <ul> <li>Use imperative mood. See something about this in this post about commit messages (which should also use imperative mood). Most of the time the title will begin with a verb, like Fix, Update or Add.</li> <li>Don't use the number of the issue it is referencing in the title but in the branch name (in the format suggested by github when you click the 'create a branch' link next to an issue). It will automatically be associated with the issue.</li> <li>The title should be self explanatory and the interpretation should not depend on the content of the issue it is referring to.</li> <li>The title should be succinct. It can not always be a full description. The users can read the rest in the PR itself. There is a link to the PR next to the entry.</li> </ul>"},{"location":"contributors-guidelines/#ordering-of-lon-lat","title":"Ordering of lon lat","text":"<ul> <li>In our code we prefor a lon, lat order consistent with the x, y order of most cartographic projections.</li> <li>Some background: The order of lon and lat always causes a lot of confusion. The official notation is lat, lon, but in map projections the lat corresponds to the y-axis and the lon to the x-axis. This is confusing because in math the ordering is the other way around: x, y. In our code we need to translate the lat/lon to an X/Y coordinate to draw it on the map. In the constructor of such a point the x (lon) will be the first parameter. There is no way that this problem can be fundamentally solved, there will always be some confusion. To mitigate it we choose one way of ordering which is lon, lat (consistent with x, y). </li> <li>Also there are many ways in which we can avoid ordering altogher. For instance if we work with Longitude and Latitude properties. In the case of SphericalMercator.FromLonLat we use lon/lat in the method name to avoid confusion.</li> </ul>"},{"location":"contributors-guidelines/#no-rendering-in-the-drawpaint-loop","title":"No rendering in the draw/paint loop","text":"<p>Mapsui strives for optiomal performance, so in the rendering loop the objects should be ready to be painted to canvas directly without any need for preparation. This is currently (4.1.0) not the case. For instance in the case of tiles they are rendered on the first iteration, after that the cached version is used. This needs to be improved.</p>"},{"location":"contributors-guidelines/#about-the-terminology","title":"About the terminology","text":"<p>Rendering: Create a platform specific resource. <pre><code>SKPath path = ToSKPath(feature, style);\n</code></pre> Drawing or Painting: Draw the platform specific resource to the canvas. <pre><code>canvas.DrawPath(path, paint);\n</code></pre></p>"},{"location":"contributors-guidelines/#keep-the-renderer-behind-and-interface","title":"Keep the renderer behind and interface","text":"<p>As of v4 Mapsui has only one renderer, SkiaSharp. Although we have only one renderer and have currently no plans to add others we will keep it behind an interface. There are costs to keeping the abstraction but we keep it because a change could happen again, even though it does not seem likely now. In the past we had to switch renderers many times, a list:</p> <ul> <li>System.Drawing</li> <li>System.Drawing for PocketPC</li> <li>Silverlight XAML</li> <li>WPF XAML</li> <li>UWP XAML (could later be merged with WPF XAML)</li> <li>iOS native rendering</li> <li>Android native rendering (this is actually internally using skia)</li> <li>OpenTK (this was not mature enough at that point)</li> <li>SkiaSharp</li> </ul>"},{"location":"contributors-guidelines/#mapsui-should-not-be-limited-to-a-single-coordinate-system","title":"Mapsui should not be limited to a single coordinate system","text":"<p>Mapsui's Map can be in any coordinate system. If you do not specify a coordinate system in the Map and Layers it assumes they are in the same coordinate system (whatever they are). In this case it only transforms these unspecified 'world-coordinates' to 'screen-coordinates' and nothing more. It is also possible to setup a coordinate transformation system using Map.CRS, DataSource.CRS and Map.Transformation. See projections.</p>"},{"location":"contributors-guidelines/#full-implementation-of-the-feature-matrix","title":"Full implementation of the feature matrix","text":"<p>These are some of the feature dimensions:</p> <ul> <li>Renderers: WPF and Skia</li> <li>Geometries: Point, LineString, Polygon etc.</li> <li>Operations on Geometries: Distance, Contains.</li> <li>Coordinate projection support</li> <li>Style: fill color, line color, line cap, symbol opacity, symbol scale </li> </ul> <p>If we choose to support a feature each 'cell' of the multi dimensional matrix should be supported. No surprises for the user. At the moment (v4.1.0) there are holes in the matrix on some point (like differences between the various platforms). </p>"},{"location":"contributors-guidelines/#put-effort-in-keeping-things-simple","title":"Put effort in keeping things simple","text":"<p>Growing complexity is one of the biggest problem in software development. To keep this project maintainable we should put effort in keeping the complixity low. Complexity can be caused by clueless spaghetti code but also by astronaut architectures. Keeping things simple is not easy but hard work. It involves thinking up several solutions to your problem weighing the pros and cons and moving it around and upside down to look for even better (simpler) solutions. </p>"},{"location":"contributors-guidelines/#continuous-refactoring","title":"Continuous Refactoring","text":"<p>Mapsui contains some older code. Don't despair. We continuously improve or replace older code. It is a gradual process. We do it step by step. Although the steps are small we have managed to make major changes in the past: from WinForms to WPF, from GDI+ to SL rendering, from .NET Framework to PCL, from PCL to .NET Standard, from WPF rendering to SkiaSharp, from Mapsui geometries to NTS. Taking such steps results in breaking changes. We are aware of this and clearly communicate it with the user. We use semver so breaking changes go in to major version upgrades.</p>"},{"location":"custom-style-renders/","title":"Custom Style Renderers","text":""},{"location":"custom-style-renders/#summary","title":"Summary","text":"<p>Mapsui 2.0 supports custom style renderers. This means a user can create a custom style and associate this with a custom style renderer to allow full freedom in rendering a feature the way the user would like.</p>"},{"location":"custom-style-renders/#how-it-works","title":"How it works","text":"<ul> <li>Create a custom style by deriving a class from IStyle. </li> <li>Assign that style to an ILayer.Style or IFeature.Styles.</li> <li>Create a custom renderer by deriving a class from ISkiaStyleRenderer and implement the Draw method.</li> <li>Register the association of the custom style to the custom style renderer as in the line below. The consequence will be that if the Mapsui renderer detects this style it will call the Draw method on the style renderer. </li> </ul> <p>This is how you register the association of a custom style to a custom style renderer <pre><code>mapControl.Renderer.StyleRenderers.Add(typeof(CustomStyle), new SkiaCustomStyleRenderer());\n</code></pre></p> <p>This is the ISkiaStyleRenderer interface that you need to implement: <pre><code>public interface ISkiaStyleRenderer : IStyleRenderer\n{\n  bool Draw(SKCanvas canvas, IReadOnlyViewport viewport, ILayer layer, IFeature feature, IStyle style, IRenderService renderService, long iteration);\n}\n</code></pre></p> <p>The IFeature has a Geometry field. The renderer is responsible to cast the IFeature.Geometry to the type it intends to render. The IStyle is the custom style the user defined. It could contain extra style information not present in the default style classes. The user will need to cast that IStyle to the custom style to use this extra information.</p>"},{"location":"custom-style-renders/#code-sample","title":"Code sample","text":"<p>Look in the Mapsui source code for CustomStyleSample.cs. </p> <p></p> <p>This is the most relevant code. In this sample the custom style contains no extra information, it is just an indication to use the associated custom renderer. It would be possible to add extra field like EarColor and NoseSize to the custom style which could be used in the renderer.</p>"},{"location":"custom-style-renders/#remarks","title":"Remarks","text":"<p>Note, that the renderer depends on the technology we use for the rendering implementation which is SkiaSharp. Theoretically we could change this implementation or add other implementations but there are no plans for that.</p>"},{"location":"documentation/","title":"Documentation","text":""},{"location":"documentation/#documentation-setup","title":"Documentation setup","text":"<ul> <li>We use mkdocs to generate the general documentation. The main configuration is in <code>./docs/general/mkdocs.yml</code>. You can test it locally by running <code>mkdocs serve</code> in that folder. The content is in the .md files in the <code>./docs/general/markdown</code> folder. To update the documentation those files need to be edited. The documentation web site has a link back to these files on github to make it easy to update them. The general docs are published to the <code>./docs/general/_site</code> folder.</li> <li>We use docfx to generate the api documentation. The main configuration is in <code>./docs/api/docfx.json</code>. You can test it locally by running <code>docfx --serve</code> in that folder. The api docs are published to the <code>./docs/api/_site</code> folder.</li> <li>The powershell script <code>./Scripts/BuildDocumentationWebSite.ps1</code> runs both mkdocs and docfx and copies both to the <code>./website</code> folder.</li> <li>The Mapsui project on github is configured to automatically publish the <code>./website</code> folder to github pages: https://mapsui.github.io/Mapsui, configured for the mapsui.com domain: https://mapsui.com.</li> <li>A pushed commit of a markdown file triggers the <code>dotnet-docs.yml</code> github action. It will run the scripts and automatically publish the new version to the website. </li> </ul>"},{"location":"documentation/#documentation-setup-guidelines","title":"Documentation setup guidelines","text":"<ul> <li>All md files should be in lower case.</li> <li>All md files should be directly in the <code>./docs/general/markdown</code> folder, not in a subdirectory. Hierachy is created by indenting page references in the toc.md in the documenation folder. By keeping the files in the root it is easier to change the hierarchy later on - you do not need to move the files as well - and it is easier to stick to the guidelines.</li> <li>All md files should start with a header one (#) and should have no other header one in the file.</li> <li>All the headers in the toc should be equal to the header one in the file it points to.</li> </ul>"},{"location":"documentation/#documentation-guidelines","title":"Documentation guidelines","text":"<ul> <li>Mapsui is cased as Mapsui not MapsUI.</li> <li>We should iteratively improve the documentation. If questions are asked in the issues we should search for the answer in the documentation. When something is missing in the documentation update the documentation and answer the question with a url to the documentation.</li> <li>Writing documentation is not only useful to inform the user but also as a sanity check for the developer. If what you have to tell becomes complicated and hard to grasp this could mean the software is not well designed. Writing documentation early should be used as a part of the software development process.</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#the-openstreetmap-layer-does-not-show","title":"The openstreetmap layer does not show","text":"<p>The most common reason is that the default user-agent used by the osm layer is blocked.  The default user-agent gets blocked by osm at some point because there is always someone somewhere abusing the api. Within your app you need to use a user-agent that is specific to your app. We change the user agent from time to time so that the samples work but it will probably get blocked again at some point. Better not to wait until that happens and create you own user-agent right away.</p> <pre><code>MapControl.Map.Layers.Add(OpenStreetMap.CreateTileLayer(\"your-user-agent\"));\n</code></pre>"},{"location":"faq/#why-is-all-my-data-in-a-small-area-near-the-west-coast-of-africa","title":"Why is all my data in a small area near the west coast of Africa?","text":"<p>This is because the background data is in SphericalMercator (it is in the SphericalMercator  coordinate system) and the foreground data is in WGS84 (latlon). Use  SphericalMercator.FromLonLat to transform it. Note: There can be many other forms of mixing up coordinate systems, but this is the most common.</p>"},{"location":"faq/#why-does-navigateto-zoom-into-an-area-near-the-west-coast-of-africa","title":"Why does NavigateTo zoom into an area near the west coast of Africa?","text":"<p>This is because the coordinates you pass to NavigateTo are in WGS84 whereas the background data is in SphericalMercator. Use SphericalMercator.FromLonLat to transform  the NavigateTo arguments to SphericalMercator. Note: There can be many other forms of mixing up coordinate systems, but this is the most common.</p>"},{"location":"faq/#how-can-i-get-rid-of-the-white-dots-or-black-lines","title":"How can I get rid of the white dots? (or black lines)","text":"<p>Set <code>Layer.Style = null</code>. In Mapsui a Style can be assigned to a ILayer and a Feature. A Layer is created with a default style which is rendered as a white dot for a <code>Point</code>, a black line for a <code>LineString</code> and a black outline for a <code>Polygon</code>. The <code>Layer.Style</code> applies to all features in the layer. If you work with a style on a feature the layer style is still drawn underneath.  </p>"},{"location":"faq/#navigation-does-not-work-when-assigning-maphome","title":"Navigation does not work when assigning Map.Home","text":"<p>Map.Home is meant to define the default extent. The Map.Home method is called when the canvas is initialzed. If you want to navigate after the app is started then call the methods on Map.Navigator.</p>"},{"location":"faq/#navigation-does-not-work-during-startup","title":"Navigation does not work during startup","text":"<p>To set the startup viewport you need to assign Map.Home. Map.Navigator does not work during startup because the canvas size is not known.</p>"},{"location":"imagesource/","title":"ImageSource","text":"<p>In Mapsui v5, image sources have been introduced, simplifying the process of assigning images to symbols. Previously, in v4, you had to load the image in your code, register it, and then assign the image ID returned from the registration to the symbol. With v5, you can directly assign the image path to the symbol.</p>"},{"location":"imagesource/#supported-path-schemes","title":"Supported Path Schemes","text":"<p>Mapsui supports three types of schemes for specifying image paths: 'http(s)', 'file', and 'embedded' (for pointing to embedded resources). Here are some examples:</p> <pre><code>myStyle.ImageSource = \"https://mapsui.com/images/logo.svg\";\nmyStyle.ImageSource = $\"file://{Environment.SpecialFolder.LocalApplicationData}/example.png\"\nmyStyle.ImageSource = \"embedded://Mapsui.Resources.Images.Pin.svg\"\n</code></pre>"},{"location":"imagesource/#image-types","title":"Image Types","text":"<p>An ImageSource can point to an SVG (supported via Svg.Skia) or a bitmap type, which can be PNG, WEBP, JPEG, and any other formats supported by SkiaSharp.</p>"},{"location":"imagesource/#types-with-an-imagesource","title":"Types with an ImageSource","text":"<p>In Mapsui 5.0.0-beta.2 the following types support the ImageSource path:</p> <ul> <li>SymbolStyle</li> <li>CalloutStyle</li> <li>Brush</li> <li>ImageButtonWidget</li> </ul>"},{"location":"imagesource/#bitmapregion-for-bitmap-types","title":"BitmapRegion for Bitmap Types","text":"<p>For bitmap types, you can specify a sub-region of the bitmap to use. This is useful for utilizing a smaller part of a bitmap or working with a meta image (or atlas) that contains multiple smaller images. </p> <p>In Mapsui 5.0.0-beta.2 the following types support the BitmapRegion:</p> <ul> <li>SymbolStyle </li> <li>Brush</li> </ul>"},{"location":"imagesource/#custom-svg-colors","title":"Custom SVG colors","text":"<p>When using an SVG, you can override the built-in colors of the stroke and fill with:</p> <ul> <li>SvgFillColor</li> <li>SvgStrokeColor</li> </ul> <p>This feature offers great flexibility, allowing you to, for instance, indicate different types of vehicles or different states of a single vehicle. </p> <p>In Mapsui 5.0.0-beta.2 only the SymbolStyle supports SvgFillColor and SvgStrokeColor.</p>"},{"location":"logging/","title":"Logging","text":"<p>Sooner or later there comes a time where you are struggling with a bug. You can save yourself some time by writing the Mapsui log events to your own log from the start of your project. In Mapsui errors and warnings are logged to a static class which has an event handler you can listen to. You can paste the code below anywhere in your app to start receiving log messages.</p> <pre><code>Mapsui.Logging.Logger.LogDelegate += (level, message, ex) =&gt;\n{\n    Console.WriteLine($\"{message} {ex?.Message}\"); // &lt;-- Put a break point here, most UI platforms do not show the console logging.\n    // todo: Forward to your own logger\n};\n</code></pre>"},{"location":"logging/#forward-mapsui-logging-to-ilogger","title":"Forward Mapsui logging to ILogger","text":"<p>This is an example of how to forward Mapsui logging to the de facto standard <code>Microsoft.Extensions.Logging.ILogger</code>. If you have configured a logger in your app, like serilog for instance, you would get Mapsui log messages in that log file. <pre><code>    public static void AttachMapsuiLogging(this IServiceProvider serviceProvider)\n    {\n        var logger = serviceProvider.GetRequiredService&lt;ILogger&lt;MyLoggerCategory&gt;&gt;();\n\n        var mapsuiPrefix = \"[Mapsui]\";\n\n        Mapsui.Logging.Logger.LogDelegate += (level, message, ex) =&gt; {\n            if (level == Mapsui.Logging.LogLevel.Error)\n                logger.LogError(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Warning)\n                logger.LogWarning(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Information)\n                logger.LogInformation(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Debug)\n                logger.LogDebug(ex, $\"{mapsuiPrefix} {message}\");\n            else if (level == Mapsui.Logging.LogLevel.Trace)\n                logger.LogTrace(ex, $\"{mapsuiPrefix} {message}\");\n        };\n    }\n</code></pre></p>"},{"location":"mapsui-components/","title":"Mapsui components","text":"<p>This part will talk about a few of Mapsui's core components. These are:</p> <ul> <li>MapControl: UI component to add to your page.</li> <li>Map: UI indepenent part which holds most of the state of the map. </li> <li>Navigator: Controls all mutations of the Viewport.</li> <li>Viewport: The state that defines which part is visible in the MapControl.</li> <li>Renderer: Draws the map in the MapControl.</li> </ul>"},{"location":"mapsui-components/#mapcontrol","title":"MapControl","text":"<p>This is the UI component that you add to you app. It is derived from a base UI component of the framework and inherits many properties related to that framework. You can control its size and positioning like any other component in your framework.</p>"},{"location":"mapsui-components/#map","title":"Map","text":"<p>The most important property of the MapControl is the Map. Unlike the MapControl the Map is platform independent. Most of the time you will be dealing with the Map or it's children. </p>"},{"location":"mapsui-components/#navigator","title":"Navigator","text":"<p>Is responsible for all Viewport manipulations, this includes:</p> <ul> <li>It checks <code>PanLock</code>, <code>ZoomLock</code>, <code>RotationLock</code>. </li> <li>It checks the pan bounds (<code>PanBounds</code>) and zoom bounds (<code>ZoomBounds</code>). Both depend on the kind of limiter that is used. </li> <li>It controls the animations. It makes sure only one viewport animation is executed at one time and a previous animation is cancelled before the new one is started. </li> <li>It calls a <code>RefreshDataRequest</code> event on a discrete viewport change or at the end of an animation (after drag or pinch RefreshData needs to called from the MapControl touch up). </li> <li>It calls the <code>ViewportChanged</code> event on all viewport changes. </li> <li>It checks the validity of the viewport state (like if it has size) before any call is executed. </li> <li>It makes sure the resolution steps are used when using <code>ZoomIn</code>, <code>ZoomOut</code> or <code>MouseWheelZoom</code>.</li> </ul>"},{"location":"mapsui-components/#viewport","title":"Viewport","text":"<p>Defines what part of the map is visible on the screen. It is a simple immutable struct that contains just state. Id is passed into the renderers and data fetchers.</p>"},{"location":"mapsui-components/#renderer","title":"Renderer","text":"<p>A member of the MapControl. Draws the map on the MapControl when RefreshGraphics is called.</p>"},{"location":"nuget-of-latest-build/","title":"NuGet of Latest Build","text":"<p>Mapsui's 'Build' GitHub action creates nugets and stores them as artifacts. Go to actions, select the build you are interested in and download them at the bottom of the page.</p>"},{"location":"performance-widget/","title":"PerformanceWidget","text":""},{"location":"performance-widget/#summary","title":"Summary","text":"<p>Mapsui 3.0 supports a widget, that could show the main performance values for drawing the map.</p>"},{"location":"performance-widget/#how-it-works","title":"How it works","text":"<p>1) Create a new Performance object for the MapControl, where the values could be stored</p> <pre><code>if (mapControl.Performance == null)\n    mapControl.Performance = new Utilities.Performance(10);\n</code></pre> <p>2) Create the PerformanceWidget. As parameter you have to provide the Performance object, that the widget should be use</p> <pre><code>var widget = new Widgets.Performance.PerformanceWidget(mapControl.Performance);\n</code></pre> <p>3) If you want to clear all values of the Performance object, then add the following event handler for the touch event of the widget</p> <pre><code>widget.WidgetTouched += (sender, args) =&gt;\n{\n    mapControl?.Performance.Clear();\n    mapControl?.RefreshGraphics();\n\n    args.Handled = true;\n};\n</code></pre> <p>4) Add the widget to the list of known widgets</p> <pre><code>mapControl.Map.Widgets.Add(widget);\n</code></pre> <p>5) To draw the widget on the screen, we need a widget renderer. To use the default widget renderer, use the following lines</p> <pre><code>mapControl.Renderer.WidgetRenders[typeof(Widgets.Performance.PerformanceWidget)] = new Rendering.Skia.SkiaWidgets.PerformanceWidgetRenderer(10, 10, 12, SkiaSharp.SKColors.Black, SkiaSharp.SKColors.White);\n</code></pre> <p>The first two parameters are the X and Y coordiantes for the widget. Third parameter is the text size. Fourth is the text color and fifth is the background color.</p>"},{"location":"performance-widget/#code-copy","title":"Code copy","text":"<pre><code>if (mapControl.Performance == null)\n    mapControl. Performance = new Utilities.Performance();\n\nvar widget = new Widgets.Performance.PerformanceWidget(mapControl.Performance);\n\nwidget.WidgetTouched += (sender, args) =&gt;\n{\n    mapControl?.Performance.Clear();\n    mapControl?.RefreshGraphics();\n\n    args.Handled = true;\n};\n\nmapControl.Map.Widgets.Add(widget);\nmapControl.Renderer.WidgetRenders[typeof(Widgets.Performance.PerformanceWidget)] = new Rendering.Skia.SkiaWidgets.PerformanceWidgetRenderer(10, 10, 12, SkiaSharp.SKColors.Black, SkiaSharp.SKColors.White);\n</code></pre>"},{"location":"performance-widget/#values","title":"Values","text":""},{"location":"performance-widget/#last","title":"Last","text":"<p>Time for drawing of the last screen. Be careful: because the widget is drawn together with the screen, this time is the time for the screen drawn before the screen you see.</p>"},{"location":"performance-widget/#mean","title":"Mean","text":"<p>The mean value is the mean of the last x draws. x is the number, you provide when creating the Performance object.</p>"},{"location":"performance-widget/#frames-per-second","title":"Frames per second","text":"<p>This is the number of frames that could be drawn with the actual mean drawing time.</p>"},{"location":"performance-widget/#minimum","title":"Minimum","text":"<p>Fastest draw of the screen.</p>"},{"location":"performance-widget/#maximum","title":"Maximum","text":"<p>Slowest draw of the screen.</p>"},{"location":"performance-widget/#count","title":"Count","text":"<p>How often the screen is drawn.</p>"},{"location":"performance-widget/#dropped","title":"Dropped","text":"<p>How often the screen isn't invalidated, because a drawing is still in progress.</p>"},{"location":"performance-widget/#remarks","title":"Remarks","text":"<p>The Performance object contains the times between start and end of a drawing process. This must not be the real drawing time. It could be, that other tasks running in between the drawing process.</p>"},{"location":"projections/","title":"Projections","text":"<p>A geospatial projection involves converting coordinates from one coordinate system to another. If all your data is within a single coordinate system, projection is unnecessary. In the context of Mapsui, projection refers specifically to geospatial transformations, not to the conversion of spatial coordinates to pixel positions on a screen, even though both can be considered transformations.</p>"},{"location":"projections/#some-background-on-projections","title":"Some Background on Projections","text":"<p>Geospatial projections are complex, and explaining them can be challenging due to the varied backgrounds of Mapsui users. Some are experienced GIS professionals, while many are app developers needing a map for their application. Below are some basic concepts to help clarify this topic. I recommend watching this video for an introduction to map projections.</p>"},{"location":"projections/#spatial-reference-system-crs","title":"Spatial Reference System (CRS)","text":"<p>In geospatial contexts, coordinate systems are referred to by their Coordinate Reference System (CRS). In Mapsui, both the <code>Map</code> and the <code>IProvider</code> have a CRS field to specify their coordinate systems.</p>"},{"location":"projections/#supported-coordinate-systems-crses","title":"Supported Coordinate Systems (CRSes)","text":"<p>By default, Mapsui supports projections between two main coordinate systems:</p> <ul> <li>EPSG:4326, also known as WGS84 or lat/lon, which is used by GPS.</li> <li>EPSG:3857, also known as SphericalMercator, WebMercator, or PseudoMercator, which is used by Google Maps and OpenStreetMap.</li> </ul> <p>You can also create custom projections by implementing the <code>IProjection</code> interface and using a projection library like ProjNet4GeoAPI.</p>"},{"location":"projections/#parts-of-mapsui-involved-in-projections","title":"Parts of Mapsui Involved in Projections","text":"<ul> <li>Map: The map itself, which is always in a specific coordinate system.</li> <li>Layers: These provide data to be displayed on the map and must return data in the map's coordinate system to avoid errors from overlapping different projections.</li> <li>Providers: Data sources for layers. If the data is in a different coordinate system, it can be converted using the <code>ProjectingProvider</code>.</li> </ul>"},{"location":"projections/#the-most-common-scenario","title":"The Most Common Scenario","text":"<p>When using OpenStreetMap, the map is in SphericalMercator, but your geodata might be in lat/lon (e.g., a GPS track).</p> <ol> <li>Set <code>Map.CRS</code> to \"EPSG:3857\" if using SphericalMercator.</li> <li>Set <code>Provider.CRS</code> to \"EPSG:4326\" if your data is in lat/lon.</li> <li>Wrap the provider in the <code>ProjectingProvider</code>. Refer to the code samples for <code>ProjectingProvider</code>.</li> </ol> <p>The <code>ProjectingProvider</code> will handle the projection for you. Alternatively, you can manually project the data using <code>Mapsui.SphericalMercator.FromLonLat</code> and <code>ToLonLat</code> before adding it to a <code>MemoryLayer</code>, which eliminates the need to set CRSes.</p>"},{"location":"projections/#remarks","title":"Remarks","text":"<ul> <li>Mapsui does not support projecting images, such as raster tiles. The CRS fields are ignored for image projections.</li> </ul>"},{"location":"projections/#sample","title":"Sample","text":"<p>[!code-csharpMain]</p>"},{"location":"projects-that-use-mapsui/","title":"Projects That Use Mapsui","text":""},{"location":"projects-that-use-mapsui/#breath-companion","title":"Breath Companion","text":""},{"location":"projects-that-use-mapsui/#squadra","title":"Squadra","text":""},{"location":"projects-that-use-mapsui/#rutas-tarija","title":"Rutas Tarija","text":""},{"location":"rendering-tests/","title":"Rendering Tests","text":"<p>Mapsui has a way of testing rendering where a Map state is rendered to a bitmap. This bitmap is then compared to the original images which are stored as resource in the repository. This is thus a kind of regresssion test (1). If there are differences between these images the test will fail. If this is the case the developer needs to visually inspect the generated images (2). If the generated image is as expected and the original is not then the original needs to be overwritten. </p> <ol> <li>Regression tests </li> <li>Visual inspection.</li> </ol> <p>The regression tests are useful during refactoring when you expect no changes. When you are working on changes in the rendered output the regression tests will fail but the visual inspection of the output is still useful to check if this is as intended.</p>"},{"location":"rendering-tests/#1-regression-tests","title":"1. Regression tests","text":"<p>The generated images are written to:</p> <pre><code>{test project folder}\\bin\\Debug\\net6.0\\Resources\\Images\\Generated\n</code></pre> <p>Those will be compared to the original images that were deployed in the build located here:</p> <pre><code>{test project folder}\\bin\\Debug\\net6.0\\Resources\\Images\\Original\\\n</code></pre> <p>If after code changes there are expected changes in the generated files they should be committed to git so they need to be copied to:</p> <pre><code>{test project folder}\\Resources\\Images\\Original\\\n</code></pre> <p>This can be done with a script: <code>scripts\\test-image-copier.cmd</code>. </p> <p>Note, only commit changes to git if the file that is modified relates to a failed test. There are many tiny changes in the files which are ignored by the tests. In that case we do not want to alter the file to avoid too many changes and avoid growth in size of the repository.</p>"},{"location":"rendering-tests/#2-visual-inspection","title":"2. Visual inspection","text":"<p>There tests can be inspected in two ways.  1. In the WPF sample there is a 'Tests' category, that shows an interactive version of the test sample. 2. In the output folder (see above) the generated images can be viewed. Currently this folder looks like this:</p> <p></p>"},{"location":"resolution/","title":"Resolution","text":"<p>In Mapsui the resolution is a value that indicates to what degree the map is zoomed in or zoomed out. A large value means you are zoomed out (see the whole world), a small value means you are zoomed in (looking at the details). The resolution of a viewport is its size in map coordinates (of the coordinate system used) devided by its size in pixels. If you use the openstreetmap background layer (or another layer in that coordinates system) the resolution is meters / pixel at the equator.</p>"},{"location":"resolution/#the-resolution-of-the-mapsui-viewport","title":"The resolution of the Mapsui viewport","text":"<p>The Viewport is an important class in Mapsui. It has a Resolution field. Its value can be directly derived from the coordinate extent and the size in pixels. So Viewport.Resolution will always be equal to Viewport.Extent.Width / Viewport.Width. The Viewport.Extent is in the units of the coordinate system (different apps can use different coordinate systems) and the Viewport.Width/Height is in pixels.</p>"},{"location":"resolution/#the-resolution-in-openstreetmap","title":"The resolution in openstreetmap","text":"<p>Mapsui's resolution concept is derived from the value for zoom levels used in openstreetmap tile schema. Openstreetmap uses the EPSG:3857 coordinate system (called SphericMercator within Mapsui). The full width of that coordinate system is 40075017 units. The top level tile in openstreetmap is 256x256 pixels. So the top level tile has a resolution of 40075017 / 256 = 156543 if is shown unscaled.</p>"},{"location":"resolution/#scale-in-meters-pixel-in-openstreetmap","title":"Scale in meters / pixel in openstreetmap","text":"<p>The coordinates of EPSG:3857 happen to be based on the circumference of the earth in meters at the equator which is 40075017 meters. This means that near the equator the units of EPSG:3875 are equal to meters. It starts to deviate when moving away from the equator. Also note that other coordinate systems can have completely different unit sizes. So the relation between the coordinate system used and meters is complicated.</p>"},{"location":"resolution/#i-am-just-interested-in-meters-pixel-and-dont-care-about-the-coordinate-system","title":"I am just interested in meters / pixel and don't care about the coordinate system","text":"<p>That makes sense but at the moment there is no good solution for that in Mapsui. What makes this complicated:</p> <ul> <li>The meters / pixel can be different in the x and y direction because of distortion of the map projection.</li> <li>The meters / pixel can be different for different locations within a single map view.</li> <li>To implement this for a coordinate system we need projection support for that coordinate system, which we may not have. </li> </ul>"},{"location":"resolution/#density-independent-pixels","title":"Density Independent Pixels","text":"<p>When we talk about pixels on this page we mean density independent pixels, or dip, or dp.</p> <p>Modern devices have a very high resolution. If something is drawn onto the canvas using raw pixels as coordinates the fonts would become tiny and unreadable and lines would become very thin. To correct for this a scale factor is used. Those scaled-up coordinates are called density independent pixels. Most of the time users deal only with the density independent pixels.</p>"},{"location":"resolution/#density-independent-pixels-in-skiasharp","title":"Density Independent Pixels in SkiaSharp","text":"<p>The scale in skia has caused some confusion in the past and bugs as a consequence. So here is some extra information on this topic. This is mainly targetted at contributors, users of the Mapsui nugets do not need to know about this.</p> <p>Most (all?) views in SkiaSharp use pixels as coordinates by default but for our purposes we need to use density independent pixels, so we need to correct for this. We do this by setting the scale of skia's SKCanvas. This needs to be done in the render loop because it is the only place where we have access to the SKCanvas. Also the size of the map needs to be adjusted at that point, otherwise we would draw outsize the screen. In later versions of SkiaSharp it is possible to use IgnorePixelScaling=true instead of scaling.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Updated Januari 2024</p>"},{"location":"roadmap/#mapsui-4","title":"Mapsui 4","text":"<p>Branch: develop/4.1. Milestone: v4.1. Mapsui v4.1.x is the stable version you should use.</p> <ul> <li> Use NTS for geometries</li> <li> License to MIT</li> <li> Improve Viewport logic</li> <li> Improve MVVM support #1731</li> <li> Improve samples</li> <li> Add MAUI MapControl</li> <li> Add Blazor MapControl</li> <li> Add Uno Platform MapControl</li> <li> Add Avalonia MapControl</li> <li> Add Eto MapControl</li> <li> Add 'getting started' tutorials for all platforms</li> <li> Keep fixing bugs</li> </ul>"},{"location":"roadmap/#mapsui-5","title":"Mapsui 5","text":"<p>Branch: main. Milestone: v5.0. We are working on a series of preview releases.</p> <p>Focus: More shared code in platforms. This will affect MapControls, Widgets and manipulation (touch and mouse). The underlying objective is to make the development process faster by removing everything that slows us down. </p> <ul> <li> Lowest supported version to .NET 6 (remove .netstandard)</li> <li> All samples and tests to .NET 8.</li> <li> Cleanup:<ul> <li> Rename master to main.</li> <li> Run dotnet format on the entire solution.</li> <li> Run dotnet style on the entire solution.</li> <li> Run dotnet analyze on the entire solution.</li> <li> Always propagate async back to the caller.</li> <li> Remove nuget packages that we previously needed for things now supported in .NET 6.</li> <li> Remove code copies of things now in .NET 6 (in the past we copied some .NET Core things which were not in .NET standard).</li> <li> Remove the #if defines we do not need anymore.</li> <li> Remove all scripts and configurations we do not use anymore.</li> <li> Simplify the build scripts now that we do not need the workarounds.</li> <li> Use <code>&lt;Nullable&gt;enable&lt;/Nullable&gt;</code> everywhere (Add to Directory.Build.props) and revisit all current suppressions.</li> <li> Fix the remaining warnings wrt IDispose.</li> </ul> </li> <li> Remove older frameworks:<ul> <li> Remove Xamarin.Forms (but not Mapsui.MAUI, Mapsui.iOS and Mapsui.Android).</li> <li> Remove Uno UWP (but not Mapsui.Uno.WinUI)</li> <li> Remove Avalonia.V0 (but not Avalonia)</li> </ul> </li> <li> Merge MapView functionality into MapControl. We need to work this out in more detail.<ul> <li> Add extension methods for Map to make it easy to add MapView functionality to the MapControl. A few:<ul> <li> AddMarkerLayer() extension which adds a layer with symbols and a callout style, which is toggled on click.</li> <li> AddOpenStreetMapBackgroundLayer() which adds to a specific layer group and sets the Map CRS and perhaps more.</li> </ul> </li> <li> Make MyLocationLayer function property in Mapcontrol.</li> <li> Add mechanism for layer grouping. Here is a proposal but perhaps we need something simpler.</li> </ul> </li> <li> Make Map dispose a layer when create function is used https://github.com/Mapsui/Mapsui/issues/2284.</li> <li> Dispose the samples if needed.</li> </ul>"},{"location":"roadmap/#mapsui-6","title":"Mapsui 6","text":"<p>Focus: Rendering.</p> <ul> <li> Two step rendering. In the draw loop only draw skia object, create skia object in an earlier step https://github.com/Mapsui/Mapsui/issues/1448</li> <li> All redering through a single pipeline https://github.com/Mapsui/Mapsui/issues/2269</li> <li> World wrap https://github.com/Mapsui/Mapsui/issues/518</li> <li> Add vector tiles https://github.com/Mapsui/Mapsui/issues/1478</li> </ul> <p>Other options:</p> <ul> <li> Add support for GeoParquet https://github.com/Mapsui/Mapsui/issues/2282</li> <li> For possible other options you could  browse through the 'design discussion' tags .</li> </ul>"},{"location":"samples/","title":"Samples","text":"<p>After going through the guickstart you should look into the samples. All samples work the same on all platforms. You can view online samples presented in Blazor here. Each sample has an accompaning 'source code' tab you can use to build your own version. </p>"},{"location":"samples/#download-samples-if-you-have-to","title":"Download samples if you have to","text":"<p>Currently the source code of the samples does not always contain all needed code. In that case you may need to clone the project and open the .slnf of your favorite UI framework. Then set Mapsui.Samples.'YourFavorityUIFramework'.csproj as startup project. If you run any of the samplea you will see there is a way to selected a category and within that category several specific samples. All these samples correspond to a specific sample class that is derived from ISample (or IMapControlSample). The most easy way to find them is to search for the name of the sample that is displayed including quotes. For instance, searching for <code>\"Points\"</code> will lead you to the file PointsSample.cs. </p>"},{"location":"touch-and-mouse-handling/","title":"Touch and mouse handling","text":"<p>In Mapsui v5 (at the moment of writing this is beta.1) most of the touch and mouse handling code is now shared over UI frameworks. There are a lot of differences between the frameworks so we need some non-shared code but we try to map it early to shared methods and components.</p>"},{"location":"touch-and-mouse-handling/#widget-event-types","title":"Widget Event types","text":"<p>In v5 beta.1 we have four new event types:</p> <ul> <li>PointerPressed (down)</li> <li>PointerMoved (can be hover for mouse)</li> <li>PointerReleased (up)</li> <li>Tapped. This can be single tap, double tap or long press.</li> </ul> <p>The names were taken from Uno/WinUI and Avalonia. Perhaps we will need other pointer event types in the future. We still have the Info event type, but this could now be replaced by the other event types because they also can be used to get the MapInfo throught a WidgetEventArgs.GetMapInfo() call.</p>"},{"location":"touch-and-mouse-handling/#components","title":"Components","text":"<ul> <li>ManipulationTracker: This component is called from the MapControl with an array of pointer positions (could be mouse or touch, or multitouch) and based on that calculates a new manipulation state (translate, scale, rotate). It is used for both drag and pinch, the difference being that while dragging the scale and rotate fields will have neutral values. The ManipulationTracker is also responsible for rotation snapping (snap out of rotation lock only when the rotation is bigger than some theshold, and snap back in when rotation is close to zero). Rotation snap was previously implemented on only a few platforms.</li> <li>TapTracker: This component detects a tap, a double tap and a long press. Prevously there were many differences in how this was implemented.</li> <li>FlingTracker: This is an old component that was previously used on just two UI frameworks and is now used on all.</li> </ul>"},{"location":"touch-and-mouse-handling/#testing-touch-and-mouse-handling","title":"Testing touch and mouse handling","text":"<p>Testing is hard. In v5 we support nine different UI frameworks and a single framework can run on different devices/platforms, like Windows, Mac, Linux, Android, iOS and WASM. With hard work you could test those once, but we are continuously making changes, and it is impossible to test all those UI frameworks on every change. You could help us by testing your own favorite UI framework. Below is checklist we used on some occasions. We are open to suggestions to expand the list:</p>"},{"location":"touch-and-mouse-handling/#touch-test-checklist-for-our-samples","title":"Touch test checklist for our samples:","text":"<ul> <li> In Widgets|Button: Tap on 'Tap me' button goes up by one.</li> <li> In Widgets|Button: Pressed next to widget, move above the widget and release there. The widget should not change the tap count.</li> <li> In Widgets|Button: Pressed on the widget, move next to the widget and release there. The widget should not change the tap count.</li> <li> In Widgets|Button: Double Tap should increase the tap count by one.</li> <li> In Widgets|Hyperlink: Tap on hyperlink should open een browser page.</li> <li> In Demo|MapInfo: MapInfo should show on the bottom left in the map.</li> <li> In Info|SingleCallout: Callout should show on tap on symbol, should disappear on a second tap on either symbol or callout.</li> <li> In Info|CustomCallout: Callout should not toggle the callout but only show info bottom left.</li> <li> In Widgets|PerformanceWidget: Tap on widget should reset the values in the widget.</li> <li> In Widgets|MouseCoordinatesWidget: The mouse coordinates should change while hovering.</li> <li> In Widgets|ZoomInOutWidget: Tap on the plus and min buttons should zoom in and out.</li> <li> In Widgets|TextBox: A mouse down or up should trigger nothing.</li> <li> In Editing|Modify: Dragging on the polygon should move the polygon not the map.</li> <li> In Editing|Rotate: Dragging on the polygon should rotate the polygon not the map.</li> <li> In Editing|Scale: Dragging on the polygon should scale the polygon not the map.</li> <li> In Editing|Modify: Add vertices to the polygon by tapping inside the polygon near the line.</li> <li> In Editing|Modify: Delete vertices by a double tap or long press on that vertex. Shift can also be used but is only implemented on a few UI frameworks. </li> </ul>"},{"location":"v4.0-upgrade-guide/","title":"v4.0 Upgrade Guide","text":""},{"location":"v4.0-upgrade-guide/#nuget-organization-changes","title":"Nuget organization changes","text":"<p>The Mapsui core package has been split up into:</p> <ul> <li>Mapsui.</li> <li>Mapsui.Tiling, which has a dependency on BruTile. It contains everything related to the raster tiles, like the TileLayer.</li> <li>Mapsui.Nts, which has a dependency on NetTopologySuite (NTS). It replaces everything that was in Mapsui.Geometries.</li> <li>Mapsui.Rendering.Skia.</li> </ul>"},{"location":"v4.0-upgrade-guide/#other-changes","title":"Other changes","text":"<ul> <li>Namespaces have changed following the nuget changes.</li> <li>Where you used Mapsui.Geometries you should now use Mapsui.Nts. The geometries themselve have been replaced by NTS.</li> <li>Mapsui.Geometries project has been removed, and replaced with NTS geometries.</li> <li>Mapsui.Geometries.Point was replaced by Mapsui.MPoint </li> <li>Mapsui.Geometries.BoundingBox was replaced by Mapsui.MRect.</li> <li>Mapsui.Projection moved to Mapsui.Projections.</li> <li>Mapsui.Rendering.Skia.CalloutType moved to Mapsui.Styles.CalloutType.</li> <li>Feature was replaced by: PointFeature or GeometryFeature or RectFeature or RasterFeature.</li> <li>The Features collection was removed and replace by and an <code>IEnumerable&lt;IFeature&gt;</code> (could be a List or Array).</li> <li>A RasterFeature now needs a RasterStyle or it will not be visible.</li> <li>The Viewport class was replaced with an immutable record. Many methods that were previously in Viewport are now in Navigator or Viewport.Extensions.</li> <li>MapControl.Navigator moved to MapControl.Map.Navigator.</li> <li>MapControl.Viewport moved to MapControl.Map.Navigator.Viewport</li> <li>INavigator was removed use Navigator instead.</li> <li>The Navigator.NavigateTo overloads were replaced with several methods with more descriptive names, like ZoomToBox.</li> </ul>"},{"location":"v5.0-upgrade-guide/","title":"v5.0 upgrade guide","text":""},{"location":"v5.0-upgrade-guide/#list-of-changes-in-the-order-that-they-were-applied","title":"List of changes in the order that they were applied.","text":"<ul> <li>Removed <code>RectFeature</code>. Instead of <code>new RectFeature(myRect)</code> use <code>new GeometryFeature(myRect.ToPolygon())</code></li> <li>Removed all events from the MAUI MapControl except for MapInfo. Use gesture recognizers instead.</li> <li>Introduced PinchState to replace separate center, radius and angle fields and used in o.a. the Map.Navigator.Pinch method.</li> <li>Moved UnSnapRotationDegrees and UnSnapRotationDegrees properties from MapControl to MapControl.Map.Navigator.</li> </ul>"}]}